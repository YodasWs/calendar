<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8"/>
<title>3D Graphics!</title>
<link rel="stylesheet" href="index.css"/>
<script src="matrix.js"></script>
<script src="webgl.js"></script>
</head>
<body>
<h1>3D Graphics!</h1>
<canvas width="640" height="480"></canvas>
<form>
	<h2>Rotation</h2>
	<label><input id="radx" type="range" min="-180" max="180" value="45"/><output>45</output></label>
	<label><input id="rady" type="range" min="0" max="360" value="35"/><output>35</output></label>
	<label><input id="radz" type="range" min="-180" max="180" value="0"/><output>0</output></label>
</form>
<script>

const gfx = (function() {
	const canvas = document.querySelector('canvas');
	const gl = canvas.getContext('webgl');

	const renderShapes = [];
	const shapes = [];

	function Shape(color) {
		this.color = color;
		this.rotation = matrix.identity(3);
		this.translation = new Array(3).fill(0);
		this.renderedNormals = [];
		this.renderedPoints = [];
		this.pointColors = [];
		this.indices = {};
		this.normals = [];
		this.points = [];
	}

	Shape.prototype = {
		render() {
			// Only recalculate if necessary
			if (this.renderedPoints.length === 0 || this.renderedNormals.length === 0 || this.pointColors.length === 0) {
				this.renderedNormals = [];
				this.renderedPoints = [];
				this.pointColors = [];

				const normal = matrix.multiply(
					this.rotation,
					matrix.form2dCol(matrix.add(
						[0, 0, 1],
						this.translation,
					)),
				);

				// Rotate and translate points from xy-plane into 3D space
				this.points.forEach((point) => {
					this.pointColors.push(this.color);
					// this.renderedNormals.push(normal);
					this.renderedNormals.push(
						matrix.multiply(
							this.rotation,
							[
								[Math.sign(point[0])],
								[Math.sign(point[1])],
								[Math.sign(this.translation[2]) || 1],
							],
						),
					);
					this.renderedPoints.push(
						matrix.multiply(
							matrix.multiply(
								this.rotation,
								matrix.form2dCol(matrix.add(
									point,
									this.translation,
								)),
							),
							1 / 640,
						),
					);
				});
			}
			return this;
		},

		rotate(yaw, pitch, roll) {
			yaw *= Math.PI / 180;
			pitch *= Math.PI / 180;
			roll *= Math.PI / 180;
			const x = [
				[1, 0, 0],
				[0, Math.cos(roll), Math.sin(roll)],
				[0, -Math.sin(roll), Math.cos(roll)],
			];
			const y = [
				[Math.cos(pitch), 0, Math.sin(pitch)],
				[0, 1, 0],
				[-Math.sin(pitch), 0, Math.cos(pitch)],
			];
			const z = [
				[Math.cos(yaw), Math.sin(yaw), 0],
				[-Math.sin(yaw), Math.cos(yaw), 0],
				[0, 0, 1],
			];
			this.rotation = matrix.multiply(
				matrix.multiply(z, y),
				x,
			);
			this.renderedPoints = [];
		},

		translate(x, y, z) {
			this.translation = [x, y, z];
			this.renderedPoints = [];
		},
	};

	function Square(x, y, width, height, color) {
		Shape.call(this, color);
		this.points = [
			[x, y, 0],
			[x, y + height, 0],
			[x + height, y + height, 0],
			[x + height, y, 0],
		];
		this.indices = [].concat([0, 1, 2], [0, 2, 3]);

		this.drawType = gl.TRIANGLES;
	}
	Square.prototype = {
		__proto__: Shape.prototype,
		constructor: Square,
	};

	function Circle(r, color) {
		Shape.call(this, color);
		this.points = [[0,0,0]];
		this.indices = [0];

		this.drawType = gl.TRIANGLE_FAN;

		let i = 0;
		for (let θ=0; θ<360; θ+=360/80) {
			this.points.push([
				r * Math.cos(θ * Math.PI / 180),
				r * Math.sin(θ * Math.PI / 180),
				0,
			]);
			this.indices.push(++i);
		}
		this.indices.push(1);
	}
	Circle.prototype = {
		__proto__: Shape.prototype,
		constructor: Circle,
	};

	return {
		Circle,
		Square,

		addShapes(...shape) {
			shapes.push(...shape)
		},

		draw() {
			const bufferData = [];
			shapes.forEach((shape) => {
				bufferData.push(shape.render());
			});
			WebGL.drawScene(bufferData);
			requestAnimationFrame(gfx.draw);
		},
	};
})();

function rotateCamera() {
	WebGL.rotateCamera(
		Number.parseInt(document.getElementById('radx').value, 10),
		Number.parseInt(document.getElementById('rady').value, 10),
		Number.parseInt(document.getElementById('radz').value, 10),
	);
}
document.getElementById('radx').addEventListener('input', rotateCamera);
document.getElementById('rady').addEventListener('input', rotateCamera);
document.getElementById('radz').addEventListener('input', rotateCamera);
rotateCamera();

function showNumbers(e) {
	e.target.closest('label').querySelector('output').innerText = e.target.value;
}
document.querySelectorAll('input[type="range"]').forEach((input) => {
	input.addEventListener('input', showNumbers);
});

const a0 = 10 * 16 +  0;
const f0 = 15 * 16 +  0;
const ff = 15 * 16 + 15;

const colors = [
	[ff / ff, a0 / ff, ff / ff, 1],
	[a0 / ff, ff / ff, ff / ff, 1],
	[ff / ff, ff / ff, a0 / ff, 1],
	[a0 / ff, ff / ff, a0 / ff, 1],
	[ff / ff, a0 / ff, a0 / ff, 1],
	[a0 / ff, a0 / ff, ff / ff, 1],
];

const cube = new Array(6).fill(0).map((f, i) => new gfx.Square(
	-100,
	-100,
	200,
	200,
	colors[i],
));

cube.forEach((face, i) => {
	const θ = new Array(3).fill(0);
	θ[i % 3] = 90;
	face.rotate(...θ);

	const translation = new Array(3).fill(0);
	translation[2] = (-1) ** (i % 2) * 100;
	face.translate(...translation);
});

const halo = new gfx.Circle(250, [
	Number.parseInt('2e', 16) / ff,
	Number.parseInt('8b', 16) / ff,
	Number.parseInt('57', 16) / ff,
	1.0,
]);

gfx.addShapes(...cube, halo);

/***********************************************************************************/
// All code below here is from MDN's WebGL Tutorial
// https://github.com/mdn/webgl-examples/blob/gh-pages/tutorial/sample5/webgl-demo.js

//
// Start here
//
(() => {
	const canvas = document.querySelector('canvas');

	// If we don't have a GL context, give up now

	if (!canvas.getContext('webgl')) {
		console.error('Unable to initialize WebGL. Your browser or machine may not support it.');
		return;
	}

	WebGL.init(canvas);

	// Draw the scene repeatedly
	requestAnimationFrame(gfx.draw);
})();

</script>
</body>
</html>
