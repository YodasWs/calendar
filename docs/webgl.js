"use strict";const WebGL=function(){let gl;let buffers;let programInfo;let shaderProgram;const init=canvas=>{gl=canvas.getContext("webgl");shaderProgram=initShaderProgram(gl);programInfo={program:shaderProgram,attribLocations:{vertexPosition:gl.getAttribLocation(shaderProgram,"aVertexPosition"),vertexColor:gl.getAttribLocation(shaderProgram,"aVertexColor")},uniformLocations:{projectionMatrix:gl.getUniformLocation(shaderProgram,"uProjectionMatrix"),cameraMatrix:gl.getUniformLocation(shaderProgram,"uCameraMatrix")}}};let cameraMatrix=matrix.flatten(matrix.identity(4));function initShaderProgram(gl){const vsSource=`
		attribute vec4 aVertexPosition;
		attribute vec4 aVertexColor;
		uniform mat4 uCameraMatrix;
		uniform mat4 uProjectionMatrix;
		varying lowp vec4 vColor;
		void main(void) {
			gl_Position = uProjectionMatrix * uCameraMatrix * aVertexPosition;
			vColor = aVertexColor;
		}
	`;const fsSource=`
		varying lowp vec4 vColor;
		void main(void) {
			gl_FragColor = vColor;
		}
	`;const vertexShader=loadShader(gl,gl.VERTEX_SHADER,vsSource);const fragmentShader=loadShader(gl,gl.FRAGMENT_SHADER,fsSource);const shaderProgram=gl.createProgram();gl.attachShader(shaderProgram,vertexShader);gl.attachShader(shaderProgram,fragmentShader);gl.linkProgram(shaderProgram);if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){console.error("Unable to initialize the shader program: "+gl.getProgramInfoLog(shaderProgram));return null}return shaderProgram}function loadShader(gl,type,source){const shader=gl.createShader(type);gl.shaderSource(shader,source);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){console.error("An error occurred compiling the shaders: "+gl.getShaderInfoLog(shader));gl.deleteShader(shader);return null}return shader}function initBuffers(gl){const positionBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);const positions=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);const faceColors=[];colors.forEach(c=>{faceColors.push(matrix.flatten([c,c,c,c]))});const colorBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(matrix.flatten(faceColors)),gl.STATIC_DRAW);const indexBuffer=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);const indices=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indices),gl.STATIC_DRAW);return{position:positionBuffer,color:colorBuffer,indices:indexBuffer}}function drawScene(points,colors,indices){buffers={};buffers["num-indices"]=indices.length;buffers.indices=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffers.indices);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indices),gl.STATIC_DRAW);[{array:points,key:"position"},{array:colors,key:"color"}].forEach(data=>{const array=matrix.flatten(data.array);const buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(array),gl.STATIC_DRAW);buffers[`num-${data.key}`]=array.length;buffers[data.key]=buffer});gl.clearColor(0,0,0,1);gl.clearDepth(1);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);const projectionMatrix=(()=>{const S=2;return matrix.flatten([[S*gl.canvas.height/gl.canvas.width,0,0,0],[0,S,0,0],[0,0,-1/2,0],[0,0,0,1]])})();{gl.bindBuffer(gl.ARRAY_BUFFER,buffers.position);gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition,3,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition)}{gl.bindBuffer(gl.ARRAY_BUFFER,buffers.color);gl.vertexAttribPointer(programInfo.attribLocations.vertexColor,4,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor)}gl.useProgram(programInfo.program);gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix,false,projectionMatrix);gl.uniformMatrix4fv(programInfo.uniformLocations.cameraMatrix,false,cameraMatrix);{const vertexCount=36;gl.drawElements(gl.TRIANGLES,buffers["num-indices"],gl.UNSIGNED_SHORT,0)}}function rotateCamera(x,y,z){cameraMatrix=matrix.flatten([...matrix.axonometric(x,y,z).map(r=>r.push(0)&&r),[0,0,0,1]])}return{initShaderProgram,rotateCamera,initBuffers,drawScene,init}}();